import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import json
import re
from datetime import datetime
import asyncio

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

class DataManager:
    def __init__(self, filename="study_data.json"):
        self.filename = filename
        self.data = self.load_data()
    
    def load_data(self):
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {"users": {}}
    
    def save_data(self):
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)
    
    def ensure_user_exists(self, user_id):
        if user_id not in self.data["users"]:
            self.data["users"][user_id] = {
                "lessons": {},
                "settings": {"notification_interval": 30, "daily_goal": 5},
                "statistics": {"total_paragraphs_read": 0, "lessons_completed": 0}
            }
            self.save_data()
    
    def get_user_data(self, user_id):
        self.ensure_user_exists(user_id)
        return self.data["users"][user_id]
    
    def split_into_paragraphs(self, text, max_length=300):
        sentences = re.split(r'(?<=[.!?])\s+', text)
        paragraphs = []
        current_para = ""
        for sentence in sentences:
            if len(current_para + sentence) <= max_length:
                current_para += sentence + " "
            else:
                if current_para:
                    paragraphs.append(current_para.strip())
                current_para = sentence + " "
        if current_para:
            paragraphs.append(current_para.strip())
        return paragraphs
    
    def add_lesson(self, user_id, text):
        self.ensure_user_exists(user_id)
        user_data = self.data["users"][user_id]
        lesson_id = str(len(user_data["lessons"]) + 1)
        paragraphs = self.split_into_paragraphs(text)
        lesson_data = {
            "id": lesson_id,
            "title": f"Ø§Ù„Ø¯Ø±Ø³ {lesson_id}",
            "content": paragraphs,
            "current_paragraph": 0,
            "completed": False,
            "created_at": datetime.now().isoformat()
        }
        user_data["lessons"][lesson_id] = lesson_data
        self.save_data()
        return lesson_data

data_manager = DataManager()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    data_manager.ensure_user_exists(user_id)
    keyboard = [
        [InlineKeyboardButton("ðŸ“š Ø¥Ø¶Ø§ÙØ© Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯", callback_data="add_lesson")],
        [InlineKeyboardButton("ðŸ“– Ø¯Ø±ÙˆØ³ÙŠ", callback_data="my_lessons")],
        [InlineKeyboardButton("ðŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="stats")],
        [InlineKeyboardButton("âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª", callback_data="settings")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("ðŸŽ“ **Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø§Ù„Ù…Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ø°ÙƒÙŠ!**\n\nØ§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª:", reply_markup=reply_markup)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = str(query.from_user.id)
    
    if query.data == "add_lesson":
        await query.edit_message_text("ðŸ“ Ø£Ø±Ø³Ù„ Ù„ÙŠ Ù†Øµ Ø§Ù„Ø¯Ø±Ø³:")
        context.user_data["waiting_for_lesson"] = True
    elif query.data == "stats":
        user_data = data_manager.get_user_data(user_id)
        stats = user_data["statistics"]
        await query.edit_message_text(f"ðŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ:**\n\nðŸ“– Ø§Ù„ÙÙ‚Ø±Ø§Øª: {stats['total_paragraphs_read']}\nâœ… Ø§Ù„Ø¯Ø±ÙˆØ³: {stats['lessons_completed']}")
    elif query.data == "my_lessons":
        user_data = data_manager.get_user_data(user_id)
        lessons = user_data["lessons"]
        if not lessons:
            await query.edit_message_text("ðŸ“­ Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© Ø£ÙŠ Ø¯Ø±ÙˆØ³ Ø¨Ø¹Ø¯.")
        else:
            lessons_text = "ðŸ“š **Ø¯Ø±ÙˆØ³Ùƒ:**\n\n"
            for lesson_id, lesson in lessons.items():
                status = "âœ…" if lesson["completed"] else "ðŸ“–"
                lessons_text += f"{status} {lesson['title']} ({lesson['current_paragraph']}/{len(lesson['content'])})\n"
            await query.edit_message_text(lessons_text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("waiting_for_lesson"):
        lesson_text = update.message.text
        user_id = str(update.effective_user.id)
        lesson_data = data_manager.add_lesson(user_id, lesson_text)
        context.user_data["waiting_for_lesson"] = False
        
        keyboard = [[InlineKeyboardButton("ðŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"âœ… **ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­!**\n\n"
            f"ðŸ“ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: {lesson_data['title']}\n"
            f"ðŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„ÙÙ‚Ø±Ø§Øª: {len(lesson_data['content'])}\n"
            f"ðŸš€ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø§Ù„Ù…Ø°Ø§ÙƒØ±Ø©",
            reply_markup=reply_markup
        )

def main():
    TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if not TOKEN:
        print("âŒ Ø£Ø¶Ù TELEGRAM_BOT_TOKEN ÙÙŠ Environment Variables")
        return
    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    print("ðŸ¤– Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Render!")
    application.run_polling()

if __name__ == "__main__":
    main()
