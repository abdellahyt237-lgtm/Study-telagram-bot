import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import json
import re
from datetime import datetime
import asyncio

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

class DataManager:
    def __init__(self, filename="study_data.json"):
        self.filename = filename
        self.data = self.load_data()
    
    def load_data(self):
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {"users": {}}
    
    def save_data(self):
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)
    
    def ensure_user_exists(self, user_id):
        if user_id not in self.data["users"]:
            self.data["users"][user_id] = {
                "lessons": {},
                "settings": {"notification_interval": 30, "daily_goal": 5},
                "statistics": {"total_paragraphs_read": 0, "lessons_completed": 0}
            }
            self.save_data()
    
    def get_user_data(self, user_id):
        self.ensure_user_exists(user_id)
        return self.data["users"][user_id]
    
    def split_into_paragraphs(self, text, max_length=300):
        sentences = re.split(r'(?<=[.!?])\s+', text)
        paragraphs = []
        current_para = ""
        for sentence in sentences:
            if len(current_para + sentence) <= max_length:
                current_para += sentence + " "
            else:
                if current_para:
                    paragraphs.append(current_para.strip())
                current_para = sentence + " "
        if current_para:
            paragraphs.append(current_para.strip())
        return paragraphs
    
    def add_lesson(self, user_id, text):
        self.ensure_user_exists(user_id)
        user_data = self.data["users"][user_id]
        lesson_id = str(len(user_data["lessons"]) + 1)
        paragraphs = self.split_into_paragraphs(text)
        lesson_data = {
            "id": lesson_id,
            "title": f"الدرس {lesson_id}",
            "content": paragraphs,
            "current_paragraph": 0,
            "completed": False,
            "created_at": datetime.now().isoformat()
        }
        user_data["lessons"][lesson_id] = lesson_data
        self.save_data()
        return lesson_data

data_manager = DataManager()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    data_manager.ensure_user_exists(user_id)
    keyboard = [
        [InlineKeyboardButton("📚 إضافة درس جديد", callback_data="add_lesson")],
        [InlineKeyboardButton("📖 دروسي", callback_data="my_lessons")],
        [InlineKeyboardButton("📊 الإحصائيات", callback_data="stats")],
        [InlineKeyboardButton("⚙️ الإعدادات", callback_data="settings")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("🎓 **مرحباً بك في بوت المذاكرة الذكي!**\n\nاختر من الخيارات:", reply_markup=reply_markup)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = str(query.from_user.id)
    
    if query.data == "add_lesson":
        await query.edit_message_text("📝 أرسل لي نص الدرس:")
        context.user_data["waiting_for_lesson"] = True
    elif query.data == "stats":
        user_data = data_manager.get_user_data(user_id)
        stats = user_data["statistics"]
        await query.edit_message_text(f"📊 **إحصائياتك:**\n\n📖 الفقرات: {stats['total_paragraphs_read']}\n✅ الدروس: {stats['lessons_completed']}")
    elif query.data == "my_lessons":
        user_data = data_manager.get_user_data(user_id)
        lessons = user_data["lessons"]
        if not lessons:
            await query.edit_message_text("📭 لم تقم بإضافة أي دروس بعد.")
        else:
            lessons_text = "📚 **دروسك:**\n\n"
            for lesson_id, lesson in lessons.items():
                status = "✅" if lesson["completed"] else "📖"
                lessons_text += f"{status} {lesson['title']} ({lesson['current_paragraph']}/{len(lesson['content'])})\n"
            await query.edit_message_text(lessons_text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get("waiting_for_lesson"):
        lesson_text = update.message.text
        user_id = str(update.effective_user.id)
        lesson_data = data_manager.add_lesson(user_id, lesson_text)
        context.user_data["waiting_for_lesson"] = False
        
        keyboard = [[InlineKeyboardButton("🏠 الرئيسية", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            f"✅ **تم إضافة الدرس بنجاح!**\n\n"
            f"📝 العنوان: {lesson_data['title']}\n"
            f"📊 عدد الفقرات: {len(lesson_data['content'])}\n"
            f"🚀 يمكنك البدء في المذاكرة",
            reply_markup=reply_markup
        )

def main():
    TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if not TOKEN:
        print("❌ أضف TELEGRAM_BOT_TOKEN في Environment Variables")
        return
    application = Application.builder().token(TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    print("🤖 البوت يعمل على Render!")
    application.run_polling()

if __name__ == "__main__":
    main()
